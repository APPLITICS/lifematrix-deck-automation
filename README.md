# Automated Slide Deck Generation from Survey Data (Phase 2 & 3)

This README describes the proposed architecture and logic for automating the creation of PowerPoint presentations from structured, preprocessed survey data. It outlines the data structure, slide generation pipeline, individual slide rendering functions, and known constraints based on initial analysis and discussions. This document corresponds to **Phase 2**, and a good starting point of **Phase 3** of the project.

---

## 📊 Data Preprocessing Strategy

### Objective

Instead of coupling data processing with visual generation, we suggest a **clean separation**: pre-calculate all values that will be displayed in the slides and store them in structured tables.

This brings two major advantages:

* **Editability**: Sari can modify target values directly before rendering (e.g., overwrite a mean value in Excel, instead of changing the raw data _to make the average equal to a specific value_).
* **Simplicity**: Keeps slide rendering functions free of calculation logic.

### Overall Workflow Steps

1. Start from raw survey data (CSV/Excel), extracted from the LIFEMATRIX API.
2. Preprocess into structured outputs ready for visual injection.
3. Save all outputs to Excel (one sheet per graph type, for instance, totaling around 6 or 7 sheets).
4. This preprocessed dataset becomes the input to the R-based slide generator.

Both steps (preprocessing + slide generation) are kept modular in the pipeline.

### Example Preprocessed Table (Concept Only)

| metric             | group      | value |
| ------------------ | ---------- | ----- |
| life\_satisfaction | all        | 7.9   |
| life\_satisfaction | HBS\_men   | 7.8   |
| life\_satisfaction | HBS\_women | 7.5   |
| joy\_percent       | xilio      | 85    |
| joy\_percent       | hbs        | 92    |

This structure allows functions to filter and map values clearly.

**❓Feasibility Check for Sari:**

> Can this preprocessing step be formalized and included as part of the pipeline?

---

## 🧩 Global Pipeline Structure

### Inputs

* Preprocessed data (as structured above)
* Instruction list (`instructions`) defining the slide layout and content logic

### Core

* Iterate over the `instructions` list and execute the corresponding slide generative functions

### Output

* A `.pptx` file containing all the slides

### Example Code Usage

```r
# Preprocess data from raw survey
preprocessed_data <- run_data_preproc(fread("raw_data.csv"))

# Define slide instructions - Each line is an instruction to generate 1 slide
instructions <- list(
  list(slide = 1, fun = "generate_density_slide", variable = "life_satisfaction"),
  list(slide = 2, fun = "generate_bar_slide", metric = "joy_percent", groups = c("xilio", "hbs"))
)

# Run main pipeline to generate the slide deck
run_pipeline(data = preprocessed_data, instructions = instructions)
```

---

## 🧱 Slide Generative Functions

Each slide is generated by a specific function tailored to its type.

### A. Density Graphs with Average

**Used In**: Slides 3–5, 29–52, 57–58

#### Inputs

* `data`: Preprocessed data
* `variable`: Target variable (e.g., `life_satisfaction`)
* `title`: (optional)
* `xlab`, `ylab`: (optional)
* `average_compare`: (optional) Named list specifying groups to display average for (max 3)

#### Example Usage

```r
generate_density_slide(
  data = preprocessed_data,
  variable = "life_satisfaction",
  average_compare = list(group = "HBS", gender = c("Women", "Men"))
)
```

#### Core Logic

* Plot a density curve of the variable
* If `average_compare` is provided, use green box(es) with Avg. values.

_💡 Developer Hint: If dynamically drawing the green box for average values (using {rvg} or similar) proves too complex, consider using pre-designed PowerPoint templates with one, two, or three-line green boxes. These can be stored in the materials folder and selected based on how many comparison values are provided._

#### Questions for Validation with Sari

1. Is the distribution always shown for the full group, and only sub-grouping on the green-box comparison legend?
2. Since it's always a density, the Y-axis show % instead of decimals? (Suggestion for better readability)
3. Are density graphs the only slide type with this green box?
4. Do we want to reuse any of Sari's plotting code to preserve style consistency? The code will still be industrialized, but it may be a good starting point for plotting functionS.  

---

### B. Bar Graphs

**Used In**: Slides 8–22 and similar

#### Observations

Bar graphs follow repeatable patterns:

* X-axis: fixed categories like "Joy", "Achievement", etc.
* Legend: 1 to 3 items (can include empty elements via `NA`)
* Always % values, making labels consistent

#### Inputs

* `data`: Preprocessed data
* `title`, `xlab`, `ylab`: (optional)
* `legend_labels`: Character vector (can include `NA`, for empty elements)
* `values`: Named list of metric values per category and legend
* `targets`: Named list of metric targets per category and legend

#### Example Instructions

Slide 8 (3 categories, no legend, no targets):

```r
list(
  fun = "generate_bar_slide",
  legend_labels = NULL,
  values = list(
    Joy = 85, # The value being extracted directly from the preprocessed data
    Achievement = 78,
    Meaningfulness = 81
  ),
  targets = NULL
)
```

Slide 9 (3 categories, single legend with an empty slot, no targets):

```r
list(
  fun = "generate_bar_slide",
  legend_labels = c("Xilio", NA),
  values = list(
    Joy = c(85, NA), # The value being extracted directly from the preprocessed data
    Achievement = c(78, NA),
    Meaningfulness = c(81, NA)
  ),
  targets = NULL
)
```

Slide 18 (3 categories, 2 non-empty legends, all with targets):

```r
list(
  fun = "generate_bar_slide",
  legend_labels = c("Xilio", "HBS"),
  values = list(
    Joy = c(85, 92), # The value being extracted directly from the preprocessed data
    Achievement = c(78, 89), 
    Meaningfulness = c(81, 91)
  ),
  targets = list(
    Joy = c(85, 92), 
    Achievement = c(78, 89), 
    Meaningfulness = c(81, 91)
  )
)
```

#### Core Logic

* Plot grouped bar chart by mapping `legend_labels` and `values`
* Use `NA` to control empty visual slots where needed

#### Open Questions

* Can all bar chart variations be captured with this approach?
* What’s the best way to handle exceptions? Are they different type of graphs? _TBD with Sari_.

---

### C. Most Common Activities (High/Low Value)

**Used In**: Slides with top activity hours

#### Inputs

* Static format? (e.g., always top 5?)
* Fixed groupings? (e.g., Xilio, HBS, etc.)

#### Suggestion

If format is constant, we could use **PPT templates** with pre-positioned text boxes, and only inject values into them.

#### Question

How dynamic are these rankings and groups? Are exceptions expected?

---

## 📌 Constraints and Considerations

### 1. Template Integration

The pipeline will also use some existing PPT templates. Input files will include:
  * Master template (title, header, background, surroundings)
  * Special layout slides (e.g., 1st intro slide, explanation, static visuals)

### 2. Single-Slide Update Capability

**Use case**: Update one slide (e.g., bar height) shortly before an event without altering the other _tweaked_ slides on regeneration.

#### Suggested Approach

* Provide optional targeting via `target_slide_id` corresponding to the order in PPT.
* Regenerate only the matching slide, reinjecting it into the existing `.pptx`

#### Caveats

* Must avoid slide order drift
* Slide identity must remain stable (e.g., naming convention or metadata tagging)
* The usage should be friendly and intuitive
* A _back-up_ logic should be implemented to avoid bad surprises
 
### 3. Visual Safeguards

* Ensure average values (e.g., `Avg. = 7.9`) in the green box don’t overlap chart elements. The print should look nice at all times.
* Pie charts must remain readable even for small segments - edge cases
* Other use cases to be discovered during developments

---

## 🚧 Next Steps

Once we agree on everything described above, here’s how we move forward:
0. Finalize and complete this documentation based on our discussion.
1. Develop the **data preprocessing pipeline**, defining the `run_data_preproc()` function, starting from the expected pre-calculated structure (resulting in one table per graph type).
2. Define and test the `instructions` list structure, with real examples for each graph type.
3. Build the core slide generation pipeline and make sure it's tested and works end-to-end.
4. Implement the key slide functions:

   * `generate_density_slide()`
   * `generate_bar_slide()`
   * And other types (to be added progressively).
5. Set up GitHub Issues with clear tasks for each function/component.
6. Confirm integration with PPT templates (e.g., base slide, green boxes, intro slides).
7. Implement and test the mechanism to update **a single targeted slide** without regenerating the full deck.
8. Deliver a first version with fully working examples from the actual presentation.

Let’s finalize this structure before diving into code.

---
